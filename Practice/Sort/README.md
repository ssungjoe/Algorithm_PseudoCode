# Problem 1

 다음 입력 리스트에 대한 제자리 선택 정렬과 제자리 삽입 정렬의 수행 내용을 예시하라.
 - 입력 리스트: 22 15 36 44 10 3 9 13 29 25
 <br>
 
 예시를 위해, 배열의 우선순위 큐 부분에 속하는 원소들을 (점선 대신) 괄호로 묶어 표시하는 방식으로 리스트의 내용을 보여라.

<br>

> 입력 리스트: 22 15 36 44 10 3 9 13 29 25
> <br>
> - 제자리 선택 정렬
> <br>
> (22 15 36 44 10 3 9 13 29 25)
> <br>
> 3 (15 36 44 10 22 9 13 29 25)
> <br>
> 3 9 (36 44 10 22 15 13 29 25)
> <br>
> 3 9 10 (44 36 22 15 13 29 25)
> <br>
> 3 9 10 13 (36 22 15 44 29 25)
> <br>
> 3 9 10 13 15 (22 36 44 29 25)
> <br>
> 3 9 10 13 15 22 (36 44 29 25)
> <br>
> 3 9 10 13 15 22 25 (44 29 36)
> <br>
> 3 9 10 13 15 22 25 29 (44 36)
> <br>
> 3 9 10 13 15 22 25 29 36 (44)
> <br>
> 3 9 10 13 15 22 25 29 36 44
> <br>
> <br>
> - 제자리 삽입 정렬
> <br>
> (22) 15 36 44 10 3 9 13 29 25
> <br>
> (15 22) 36 44 10 3 9 13 29 25
> <br>
> (15 22 36) 44 10 3 9 13 29 25
> <br>
> (15 22 36 44) 10 3 9 13 29 25
> <br>
> (10 15 22 36 44) 3 9 13 29 25
> <br>
> (3 10 15 22 36 44) 9 13 29 25
> <br>
> (3 9 10 15 22 36 44) 13 29 25
> <br>
> (3 9 10 13 15 22 36 44) 29 25
> <br>
> (3 9 10 13 15 22 29 36 44) 25
> <br>
> (3 9 10 13 15 22 25 29 36 44)
> <br>
> 3 9 10 13 15 22 25 29 36 44


<br>

# Problem 2
 제자리 삽입 정렬에 대한 최악의 입력 리스트의 예를 들어라. 또한 그러한 리스트에 대해 제자리 삽입 정렬이 Ohm(n^2) 시간에 수행함을 설명하라.

<br>


> 최악의 경우 : 역순(내림차순)으로 정렬된 리스트인 경우
> <br>
> pass = 1 : 1회 비교
> <br>
> pass = 2 : 2회 비교
> <br>
> pass = 3 : 3회 비교
> <br>
> ...
> <br>
> pass = n-1 : n-1회 비교
> <br>
> 즉 내부 루프에서의 비용은 1+2+3+...+(n-1) = n(n-1)/2 이다
> <br>
> 즉 수행 시간은 최소 cn^2에 비례해 증가하므로 시간 복잡도는 Ohm(n^2) 이다

<br>

# Problem 3

배열 A의 n개의 원소를 제자리에서 정렬하는 inPlaceSelectionSort(A)를 구현해라
<br>

```
Alg inPlaceSelectionSort(A) : O(n^2)
    input array A of n keys
    output sorted array A

1. for pass ← 0 to n-2
       minLoc ← pass
       for j ← (pass+1) to n-1
           if (A[j] < A[minLoc])
               minLoc ← j
       A[pass] ↔ A[minLoc]
2. return
```

<br>

# Problem 4

배열 A의 n개의 원소를 제자리에서 정렬하는 inPlaceInsertionSort(A)를 구현해라
<br>

```
Alg inPlaceInsertionSort(A) : O(n^2)
    input array A of n keys
    output sorted array A

1. for pass ← 1 to n-1
       save ← A[pass]
       j ← pass-1
       while ((j≥0) & (A[j]>save))
           A[j+1] ← A[j]
           j ← j-1
       A[j+1] ← save
2. return
```